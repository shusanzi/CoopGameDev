## 完善武器功能

### 创建武器

#### 创建武器类
一个 Acotr 类，添加 Mesh 组件。
```
MeshComp = CreateDefaultSubobject<USkeletalMeshComponent>(TEXT("MeshComp"));
RootComponent = MeshComp;
```
蓝图中添加 Mesh 模型。

#### 人形模型添加武器

- 通过Make Transform构造Transform变量

人形的蓝图中，从事件 BeginPlay 中拉出一个【生成 Actor】，class 填上武器蓝图，Spwan Transform 填上一个 Make Transform，在 Collision Handling Override 中选择 Always Spawn，接下来 Return Value 指向 AttachToComponent，Socket Name 是插槽名称。Rule 全部选为 Snap To Target，Parent 为人形 Pawn 的 Mesh。

**添加武器插槽**
打开人形模型，选择骨架，选择 hand_r，右键添加插槽，命名为 WeaponSocket。
预览后调整插槽的位置。

![](https://github.com/shusanzi/Picture/blob/master/CoopGameDev/2.png)


### 射线
添加一个 Fire 的函数，声明为：UPROPERTY(BlueprintCallable, Category = "Weapon")

**LineTraceSingleByChannel**

GetWorld()->LineTraceSingleByChannel 判断是否击中物体，需要四个参数，击中物体信息，初始位置，结束位置，碰撞通道，碰撞查询参数。

击中物体结果：**FHitResult**
初始位置：**GetActorEyesViewPoint** 获取Actor双眼视角，返回眼睛位置
结束位置：**GetActorEyesViewPoint** 获取Actor双眼视角，返回眼睛位置及视角，乘上一个距离（10000），得出结束位置
碰撞通道：以后会优化自己的通道，现在使用可见性通道**ECC_Visibility**
碰撞查询参数：**FCollisionQueryParams** 需要忽略武器，Pawn，复合追踪设置为真，精度更高，比如爆头等

```
AActor* MyOwner = GetOwner();
if (MyOwner) {
	FHitResult Hit;

	FVector EyeLocation;
	FRotator EyeRotation;
	MyOwner->GetActorEyesViewPoint(EyeLocation, EyeRotation);
	FVector TraceEnd = EyeLocation * (EyeRotation.Vector() * 10000);

	FCollisionQueryParams QueryParams;
	QueryParams.AddIgnoredActor(MyOwner);
	QueryParams.AddIgnoredActor(this);
	QueryParams.bTraceComplex = true;

	if (GetWorld()->LineTraceSingleByChannel(Hit, EyeLocation, TraceEnd, ECC_Visibility, QueryParams)) {
		
	}
}
```

绘制射线
DrawDebugLine(GetWorld(), EyeLocation, TraceEnd, FColor::White, false, 1.0f, 0, 1.0f);

蓝图中：
